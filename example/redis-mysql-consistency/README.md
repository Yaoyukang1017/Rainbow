MySQL 和 Redis 的数据一致性问题
===

## 怎么理解缓存双写一致性？

如果 Redis 中有数据，需要与数据库中值相等。如果 Redis 中无数据，则不需要处理，下次读将会回写最新的数据到缓存中

## 缓存分类

根据是否接收写请求而分为 `只读缓存` 和 `读写缓存`。


## 数据库和缓存一致性的几种更新策略(只保证最终一致性)

`给缓存设置过期时间`，是保证最终一致性的解决方案。`所有的写操作以数据库为准`，对缓存操作尽最大努力即可。所以一切以更新缓存优先的操作都是不允许的。


### 先更新数据库，再更新缓存

**无并发情况**

可能会出现`更新数据库成功，而更新缓存失败`的情况出现，结果就是请求命中缓存时读取到的还是旧的数据，解决方案
是 `订阅 biglog + 消息队列 + 重试机制`。

**高并发情况**

| 并发类型    | 潜在问题                                                                    | 影响程度                                      |
|---------|-------------------------------------------------------------------------|-------------------------------------------|
| 写 + 读并发 | 1.线程A先更新数据库<br/> 2.线程B读取数据，命中缓存，读取到旧值<br/> 3.线程A更新缓存成功，后续的读请求会命中缓存得到最新值 | 这种场景下，线程A未更新缓存之前，在这期间的读请求会短暂读到旧值，对业务短暂影响。 |
| 写 + 写并发 | 1.线程A和线程B同时更新同一条数据<br/> 2.更新数据库的顺序是先A后B<br/> 3.更新缓存的缓存为先B后A             | 会导致数据库和缓存的不一致，对业务影响较大                     |


针对第一种情况，如果能够容忍短暂的不一致，可以不作处理，如果无法容忍可以使用强一致性的方案。
针对第二种情况，对于写请求使用`分布式锁`，写请求进来的时候，如果是对同一个资源的修改操作，先加分布式锁，保证同一时间内只有一个线程去更新数据库和缓存；没有
拿到锁的线程把操作放入队列中，延时处理。用这种方式保证多个线程操作同一个资源的顺序性，以保证一致性。


### 先删除缓存，再更新数据库

先不过其他的，首先删除缓存会使 mysql 出现 `缓存击穿` 的风险。

**无并发情况**

可能会出现 `删除缓存成功，而更新数据库失败`的情况。这种情况属于正常，后续的读请求读到的数据库的数据并回写到缓存中。从头到尾都是以数据库的值为准，并无问题。

**高并发情况**

假设线程A删除缓存后，由于网络延迟等原因未及时更新数据库，而此时，线程B发现缓存缺失，进而查询数据库。而当线程B从数据库读取完数据后，更新了缓存后，线程A
才开始更新数据库。此时会导致缓存中是旧值，数据库中的是新值。针对这种情况，可以使用 `设置缓存过期时间 + 延时双删`策略。

解决思路: 设置缓存过期时间 + 延时双删**

通过延时双删进行保障: 在线程A更新完数据库之后，让它 sleep 一小段时间，确保线程B能够先从数据库读取数据，再把缺失的数据写入缓存，然后线程A再进行删除，
后续其他线程读取数据时，发现缓存缺失，会从数据库中获取最新值。线程 sleep 的时间，就需要大于线程 B 读取数据再写入缓存的时间，在此基础上加上几百 ms。
如果是主从架构还需要加上主从同步数据的时间。


### 先更新数据库，再删除缓存

依旧分为无并发和高并发的情况。无并发的情况下，其中一个操作失败的情况.并发的情况下，其他线程可能会读到旧值。


## 强一致性策略

上述的策略只能保证最终一致性。要想做到强一致性，最常见的方案是 2PC、3PC、Paxos、Raft 这类一致性协议，但它们的性能往往比较差，而且这些方案也比较复杂，
还要考虑各种容错问题。如果业务层要求必须读取数据的强一致性，可以采用以下策略:

1. 使用 Redis 分布式读写锁

将淘汰缓存和更新库表放入同一把读写锁中，与其他读请求互斥，防止期间产生旧数据，读写互斥、写写互斥、读读共享，可满足读多写少的场景的数据一致问题，也保证了
并发性，

```
public void write() {
    
    Lock writeLock = redis.getWriteLock(lockKey);
    writeLock.lock();
    try {
        redis.delete(key);
        db.update(record);
    } finally {
        writeLock.unlock();
    }
}

public void read() {
    
    if (caching) {
        return;
    }
    Lock readLock = redis.getReadLock(lockKey);
    readLock.lock();
    try {
        record = db.get();
    } finally {
        readLock.unlock();
    }
    redis.set(key, record);
}
```






