#### 使用 redis HyperLogLog 数据结构实现 UV 指标采集和展示

##### 什么是 HyperLogLog ?

Redis HyperLogLog 是用来做基数统计的算法。HyperLogLog 的优点是在输入元素数量和体积都非常大的情况下，
计算基数所需的空间总是固定并且很小的。

在 Redis 里面，每个 HyperLogLog 键只需要花费 12KB 的内存，既可以计算将近 2^64个不同元素的基数。但是因为
HyperLogLog 只会根据输入元素来计算基数，而不会存储输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。

HyperLogLog 的基数估计是有误差率的 大约为 0.81%。

##### 什么是基数？

比如数据集 {1, 3, 5, 7, 5, 7, 8}, 那么这个数据集的基数集 {1, 3, 5, 7, 8}, 基数(不重复的元素)为 5。

##### 什么是 PV、UV、DAU、MAU?

UV: Unique Visitor，独立访客，一般理解为客户端IP。需要去重考虑。
PV: Page View，页面浏览量。
DAU: Daily Active User，日活跃用户量。
MAU: MonthIy Active User，月活跃用户量。

##### 问题：还有 Redis 集群的插槽为什么是 16384 个?

Redis 集群并没有使用一致性 hash 而是引入哈希槽的概念。Redis 集群中有 16384 个哈希槽，每个 key 通过 CRC16 校验
后对 16384 取模来决定放置在哪个槽，集群中的每个节点负责一部分 hash 槽。但为什么哈希槽的数量是 16384(2 ^ 14) 个呢？
CRC16 算法产生的 hash 值有 16 bit，该算法可以产生 2 ^ 16 = 65536 个值。那为什么 mod 运算的时候不 mod 65536，
而是 mod 16384？

1. 如果槽位为 65536，发送心跳信息的消息头达 8k，发送的心跳包过于庞大。消息头是最占空间的 myslots[CLUSTER_SLOT/8]
当槽位为 65536 时，这块大小为 65536 / 8 / 1024 = 8k，因为每秒钟 redis 的节点需要发送一定数量的 ping 消息作为
心跳包，如果槽位为 65536，这个 ping 消息的消息头太大了，浪费带宽。
2. redis 的集群主节点数量基本不可能超过 1000 个。集群节点越多，心跳包的消息体内携带的数据越多。如果节点超过 1000 个，
也会导致网络拥堵。因此，redis 的作者不建议 redis cluster 节点的数量超过 1000 个。那么，对于节点数在 1000 以内的
redis cluster 集群，16384 个 槽位够用了，没有必要扩展到 65536 个。
3. 槽位越小，节点少的情况下，压缩比高，容易传输 Redis 主节点的配置信息中它所负责的哈希槽 
是通过一张bitmap的形式来保存的，在传输过程中会对bitmap进行压缩，但是如果bitmap的
填充率slots / N很高的话(N表示节点数)，bitmap的压缩率就很低。 
如果节点数很少，而哈希槽数量很多的话，bitmap的压缩率就很低。


##### 常用命令

* PFADD
* PFCOUNT
* PFMERGE

```
// 假设用户 A、B、C、D、E、F 在 18 点至 19 点之间登录了系统
pfadd USER:LOGIN:2022020918 A B C D E F

// 计算 18 点登录的人数
pfcount USER:LOGIN:2022020918

// 对 18 点到 20 点之间有多少人登录到系统，使用合并计数
pfcouunt USER:LOGIN:2022020918 USER:LOGIN:2022020919

// 避免每次进行合并计数，可以将合并结果保留
pfmerge USER:LOGIN:2022020918-19 USER:LOGIN:2022020918 USER:LOGIN:2022020919
```
