垃圾收集器G1
===

## G1 收集器(-XX:+UseG1GC)

G1(Garbage-First)是一款面向服务器的逻辑收集器，**主要针对配备多个处理器及大容量内存的机器**。以极高概率满足 GC 停顿时间要求的同时，还具备
高吞吐量的性能特征。

![G1 内存划分](http://yuko.top:9099/images/2022/03/14/4205a31b245f4979a39d18dbe382a8da.png)

特点:
1. G1 保留了年轻代和老年代的概念，但是不再是物理隔阂的，它们是不连续的 Region集合。G1 将 Java 堆划分为了多个大小相同独立区域(Region)。 
Region的 数量计算公式： 堆大小 / 2048。比如堆大小为 4096M，则对应的 Region 大小为 4096M/2048 = 2M。当然也可以使用参数 
`-XX:G1HeapRegionSize` 设定每个 Region 的大小，但是更推荐默认的计算方式。
2. G1 中年轻代的占比是动态变化的。默认初始占比为 5%。但随着系统的运行，系统会不断增加年轻代的比例，但是不会超过 60%。
3. G1 中 Eden:Survivor0:Survivor 的比例依旧为 8:1:1。
4. G1 中的 Region 区域功能会不断变化的。比如 Region 之前为为年轻代，但是经过垃圾回收之后，可能 Region 就变为老年代。
5. G1 收集器中有对大对象做不同的处理，G1 中专门有分配大对象的 Region 叫做 Humongous 区。 G1 中判断大对象的规则是是否超过一个 Region 大小的 50%。
如果一个大对象太大，可能会横跨多个 Region 来存放。Humongous 区专门用于存放短期巨型对象，不用直接进入老年代，可以节约老年代的空间，避免因为老年代空间
不够而引起的 GC 开销。


### G1 收集器执行过程

G1 收集器一个 GC(Mixed GC)主要包括以下过程：
* **初始标记**(initial mark, STW): 暂停所有的其他线程，并记录下 gc root 能够直接引用的对象，速度很快:
* **并发标记**(Concurrent Marking): 并发标记阶段就是从 GC Roots 的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发
  运行。因为用户程序继续运行，可能会有导致已经标记过的对象状态发生变化。
* **最终标记**(Remark, STW): 修正并发标记阶段因为用户线程继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间会比初始标记稍长，但
  远比并发标记时间短。
* **筛选回收**(Cleanup, STW): 筛选回收阶段**首先对各个 Region 的回收价值和成本进行排序，根据用户所期待的GC停顿时间来制定回收计划，** 举个例子，
比如说老年代此时有1000个 Region 都满了，但是根据预期停顿时间，本次垃圾回收可能只能停顿200毫秒，那么通过之前回收成本计算得知，可能回收其中800个Region
刚好需要200毫秒，那么就只会回收800个Region，尽量把GC导致的停顿时间控制在我们设定的范围内，

![G1 执行过程](http://yuko.top:9099/images/2022/03/23/202203231438.png)

G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值的 Region(Garbage-First的由来)，比如一个 Region 花 200ms 能回收
10M 垃圾，另外一个 Region 花 50ms 能回收 20M 垃圾，在回收时间有限的情况下，G1 会优先选择后一个 Region 回收。

G1 收集器垃圾回收特点：
* **并行与并发**: G1 能充分利用 CPU、多核环境下的硬件优势，使用多个核心来减少 Stop-The-World 的时间。
* **分代收集**: 虽然 G1 不需要其他收集器配合就能独立管理整个堆，但是还是保留了分代的概念。
* **空间整合**: 与 CMS 的`标记-清理`算法不同，G1 收集器从整体来看像是`标记-整理`算法，但实际上是基于"复制"算法实现的。
* **可预测的停顿**: 这是 G1 相对于 CMS 的另一个优势，降低停顿时间是 G1 和 CMS 共同关注的点，但 G1 除了追求低停顿以外，还能建立**可预测的停顿时间
模型**，可以指定一个长度为M毫秒的时间片段内完成垃圾收集(通过参数 `-XX:MaxGCPauseMillis`).

> 如果合理地指定停顿时间？

设置合理的停顿时间，使得吞吐量和延迟之间得到合理平衡。默认的停顿目标为两百毫秒。
如果设置的停顿时间较短，比如20毫秒，可能出现的情况是停顿时间过短，每次选出来的回收集只占堆内存很小的一部分，收集器收集的速度跟不上分配器分配的速度，导致
垃圾慢慢堆积，运行时间一长就会出现堆内存堆满引发 Full GC，反而降低性能。所以通常设置时间为100ms ~ 300ms较为合理。

### G1 垃圾收集分类

* **YoungGC**: YoungGC 并不是说现有的 Eden Region 区放满了就会马上触发，它会计算现在 Eden 回收要多久，如果回收时间远远小于参数 
`-XX:MaxGCPauseMillis` 设定的值，那么增加年轻代的 region，继续给新对象存放，不会马上做 Young GC，直到下一次 Eden 区放满，G1 计算回收时间
接近 `-XX:MaxGCPauseMillis` 设定的值，那么就会触发 YoungGC.
* **MixedGC**: 在老年代的堆占有率达到参数(`-XX:InitiatingHeapOccupancyPercent`)设定的值则触发，回收所有的 Young 和部分的 Old 以及
大对象区，正常情况下 G1 的垃圾收集是先做 MixedGC，主要使用复制算法，需要把各个 region 中存活的对象拷贝到别的 region 里去，拷贝过程中如果发现没有
足够的 region 能够承载拷贝对象就会触发一次 Full GC.
* **Full GC**: 停止系统程序，然后采用单线程进行标记、清除、整理。

### G1 收集器参数设置

* -XX:UseG1GC: 使用 G1 收集器。
* -XX:ParallelGCThreads: 指定 GC 工作的线程数量。
* -XX:G1HeapRegionSize: 指定分区大小(1MB ~ 32MB，且必须是2的N次幂)，默认将整堆划分为2048个分区。
* -XX:MaxGCPauseMillis: 目标暂停时间(默认 200ms)。
* -XX:G1NewSizePercent: 新生代内存初始空间(默认整堆5%)
* -XX:TargetSurvivorRatio: Survivor 区的填充容量(默认是50%), Survivor 区域里对象总和超过 Survivor 区的 50%，就会把年龄n(含以上)的对象都放入老年代。
* -XX:MaxTenuringThreshold: 最大年龄阈值(默认15).
* -XX:InitiatingHeapOccupancyPercent: 老年代占用空间达到整堆内存阈值(默认45%)，则执行新生代和老年代的混合收集(Mixed)，比如说之前的说的堆有
2048个 region，如果有超过1000个region都是老年代的region，则可能就要触发 MixedGC。
* -XX:G1MixedGCLiveThresholdPercent(默认85%) region 中存活对象低于这个值才会回收该 region。
* -XX:G1MixedGCCountTarget: 在一次回收过程中指定做几次筛选回收(默认8次).
* -XX:G1HeapWastePercent(默认5%): gc过程中空出来的 region 是否有空闲阈值，在混合回收的时候，对 Region 的回收是基于复制算法进行的，都是把要
回收的 Region 里的存活对象存入其他 Region，然后这个 Region 中的垃圾对象全部清理掉，这样在回收过程中会不断空出来新的 Region，一旦空闲出来的 Region
数量达到堆内存的 5%，此时就会停止混合回收。

### 什么场景适合使用 G1

* 50% 以上的堆被存活对象占用。
* 对象分配和晋升的速度变化非常快。
* 垃圾回收时间特别长，超过1s。
* 8GB以上的堆内存(建议值)。
* 停顿时间是500ms以内。





