垃圾收集算法与垃圾收集器ParNew&CMS
===

## 垃圾回收算法

### 分代收集理论

当前的虚拟机的垃圾收集都采用分代收集算法，根据对象的存活周期的不同将内存分为几块。一般将 Java 堆分为新生代和老年代，再根据各个年代的特点选择合适的垃圾
收集算法。比如在新生代中，每次收集都会有大量(99%)的对象死去，所以选择复制算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活
几率较高的，而且没有额外的空间对它进行分配担保，所以需要选择"标记-清除"或"标记-整理"算法进行垃圾收集，这两种算法都比复制算法慢上10倍以上。

### 标记-复制算法

为了解决效率问题，"复制"收集算法出现了。它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用后，就将还存活的对象复制到另一块去，然后
再把使用的空间一次清理掉。

![标记-复制](http://images.yuko.top/images/2022/03/08/96D6C205961C401FA08A222DD296F101.jpg)


### 标记-清除算法

算法分为"标记"和"清除"阶段: 标记存活的对象，统一回收所有未被标记的对象； 也可以反过来，标记出所有需要回收的对象，在标记完成后统一回收所有已标记的对
象。它是最基础的收集算法，但是会带来两个问题：
1. 效率问题(如果需要标记的对象太多，效率不高)
2. 空间问题(标记清除后会产生大量不连续的碎片)

![标记-清除](http://images.yuko.top/images/2022/03/08/9EA2822391964677B532FA20BA6C1CFE.jpg)


### 标记-整理算法

根据老年代的特点的一种标记算法，标记过程仍然与"标记-清除"算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活对象向一端移动，然后直接清理掉端
边界以外的内存。

![标记-整理](http://images.yuko.top/images/2022/03/08/96BA7C6A2FE44EECBE32B64ADA05E03F.jpg)


## 垃圾收集器

### Serial 收集器(-XX:+UseSerialGC -XX:+UseSerialOldGC)

Serial (串行) 收集器是最基本、历史最悠久的垃圾收集器。它是一个单线程收集器，在它进行垃圾收集工作的时候必须暂停其他所有的工作线程(**Stop The World**),
直到它收集结束。**新生代采用复制算法，老年代采用标记-整理算法。**

![Serial 收集过程](http://images.yuko.top/images/2022/03/08/1C5BBB8EFDA34D30A04C67EB39C32E43.jpg)

虽然 Serial 收集器有 STW 的不良体验，但是 Serial 收集器也有优于其他收集器的地方。**它简单而高效(与其他收集器的单线程相比)**。Serial 收集器由于
没有线程交互的开销，自然可以获得很高的单线程收集效率。

Serial Old 收集器是 Serial 收集器的老年代版本，它同样是一个单线程收集器。它主要有两大用途: 一种用途是在 JDK1.5 以及以前的版本中与 Parallel 
Scavenge 收集器搭配使用，另一种用途是作为 CMS 收集器的后备方案。

### Parallel Scavenge 收集器(-XX:+UseParallelGC -XX:+UseParallelOldGC)

Parallel 收集器其实是 Serial 收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为(控制参数、收集算法、回收策略等等)和 Serial 收集器类似。
默认的收集线程跟 cpu 核数相同，也可以通过参数 -XX:ParallelGCThreads 指定线程数量，但是一般不推荐。

**Parallel Scavenge 收集器关注点是吞吐量(高效率地利用 CPU)。CMS 等垃圾收集器的关注点更多的是用户线程的停顿时间(提高用户体验)。所谓吞吐量就是
就是 CPU 中用于运行用户代码的时间与 CPU 总消耗时间的比值。新生代采用的是复制算法，老年代使用的是标记-整理算法。**

![Parallel Scavenge 收集过程](http://images.yuko.top/images/2022/03/08/F4928A43F18645A8891088AC5A0BC9C6.jpg)

Parallel Old 收集器是 Parallel Scavenge 收集器的老年代版本，使用多线程和"标记-整理"算法，在注重吞吐量以及 CPU 资源的场合，都可以优先考虑
Parallel Scavenge 收集器和 Parallel Old收集器(JDK8默认的新生代和老年代收集器)

### ParNew 收集器(-XX:+UseParNewGC)

ParNew 收集器其实跟 Parallel 收集器很类似，区别主要在于它可以跟 CMS 收集器配合使用。新生代采用复制算法，老年代采用标记-整理算法。

### CMS 收集器(-XX:+UseConcMarkSweepGC)

**CMS(Concurrent Mark Sweep) 收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验上的应用使用，它是 HotSpot 虚拟机第一款
真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程同时工作。**

CMS 收集器是由"标记-清除"算法实现的，主要过程分为四个步骤:
* 初始标记: 暂停所有的其他线程(STW)，并记录下 gc roots 直接能引用的对象，速度很快。
* 并发标记: 并发标记阶段就是从 GC Roots 的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发
运行。因为用户程序继续运行，可能会有导致已经标记过的对象状态发生变化。
* 重新标记: 重新标记阶段就是为了修正并发标记阶段因为用户线程继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间会比初始标记稍长，但
远比并发标记时间端。主要是用到三色标记里的增量更新算法来做重新标记。
* 并发清理: 开启用户线程，同时 GC 线程开始对未标记区域做清扫。这个阶段如果有新增对象将会被标记成黑色并不作处理。
* 并发重置: 重置本次 GC 过程中的标记数据。

![CMS 收集过程](http://images.yuko.top/images/2022/03/08/E22D67705EE44F509442E7CD3B705910.jpg)

CMS 收集器的主要优点是 **并发收集、低停顿**。但是它也有几个明显的缺点：
* 对 CPU 资源敏感(会和服务抢资源)。
* 无法处理**浮动垃圾**(在并发标记和并发清理阶段又产生垃圾，这种浮动垃圾只能等到下一次 gc 再清理了)
* 它使用的算法是**标记-清除**，该算法会产生大量的空间碎片，当然可以通过 -XX:+UseCMSCompactAtFullCollection 可以让 jvm 在执行完标记清除后再做整理。
* 执行过程的不确定性，会存在上一次垃圾回收还没执行完，然后垃圾回收又被触发的情况，特别是并发标记和并发清理阶段会出现，一边回收，系统一边运行，也许还没回收完
就再次触发 Full gc，也就是 "concurrent mode failure"，此时会进入 stop the world， 用 serial old 垃圾收集器来回收。

CMS 的相关核心参数:
1. -XX:+UseConcMarkSweepGC: 启用 cms
2. -XX:ConcGCThreads: 并发的 GC 线程数
3. -XX:+UseCMSCompactAtFullCollection: Full GC 之后做压缩整理(减少碎片)
4. -XX:CMSFullGCsBeforeCompaction: 多少次 FullGC 之后压缩一次，默认是 0，代表每次 FullGC 都会压缩一次。
5. -XX:CMSInitiatingOccupancyFraction: 当老年代使用达到该比例时会触发 Full GC(默认是92，这是百分比)。
6. -XX:CMSInitiatingOccupancyOnly: 只使用设定的回收阀值(-XX:CMSInitiatingOccupancyFraction设置的值)，如果不指定，JVM 仅在第一次使用
设定值，后续则会自动调整。
7. -XX:CMSScavengeBeforeRemark: 在 CMS GC 前启动一次 minor gc，降低 CMS GC 标记阶段(也会对年轻代一起做标记，如果在 minor gc 就干掉了
很多的垃圾对象，标记阶段就会减少一些标记时间)的开销，一般 CMS 的 GC 耗时 80% 都在标记阶段。
8. -XX:+CMSParallellnitialMarkEnabled: 表示在初始阶段的时候多线程执行，缩短 STW。
9. -XX:+CMSParallelRemarkEnabled: 在重新标记的时候多线程执行，缩短 STW。

## 垃圾收集底层算法实现

### 三色标记

在并发标记的过程中，因为标记期间应用线程还在继续跑，对象间的引用可能发生变化，多标或者漏标的情况就可能发生。三色标记算法就是用来解决这个问题，
**三色标记:**把 GC roots 可达性分析遍历对象过程中遇到的对象，按照"是否访问过"这个条件标记成三个颜色:
* 黑色: 表示对象已经被垃圾收集器访问过，且这个对象的所有引用都已经扫描过。黑色的对象代表已经扫描过，它是安全存活的，如果有其他对象引用指向了黑色对象，
无须重新扫描一遍。黑色对象不可能直接(不经过灰色对象)指向某个白色对象。
* 灰色: 表示对象已经被垃圾收集器访问过，但这个对象至少存在一个引用还没有被扫描过。
* 白色: 表示对象尚未被垃圾收集器访问过。显然在可达性分析刚开始的阶段，所有对象都是白色的，若在分析结束的阶段，仍是白色的对象，即代表不可达。

```java
public class ThreeColorRemark {
    
    public static void main(String[] args) {
        A a = new A();
        // 开始做并发标记
        D d = a.b.d;  // 1. 读
        a.b.d = null; // 2. 写
        a.d = d;      // 3. 写
    }
    
    class A {
        B b = new B();
        D d = null;
    }
    
    class B {
        C c = new C();
        D d = new D();
    }
    
    class C {
        
    }
    
    class D {
        
    }
}
```

![标记过程](http://images.yuko.top/images/2022/03/08/clipboard-6.png)


### 多标 - 浮动垃圾

在并发标记的过程中，如果由于方法运行结束导致部分局部变量(gcroot)销毁，这个 gcroot 引用的对象之前又被扫描过(被标记成非垃圾对象)，那么本轮 GC 不会
回收这部分内存，这部分本该回收但是没有回收到的内存，被称之为**浮动垃圾**。浮动垃圾并不影响垃圾回收的正确性，只是要等到下一轮垃圾回收才被清除。另外，
**针对并发标记(还有并发清理)开始产生的新对象，通常的做法是直接全部当成黑色。** 本轮不会进行清除。这部分对象期间可能也会变为垃圾，也算是浮动垃圾的一部分。

### 漏标 - 读写屏障

漏标会导致被引用的对象被当成垃圾误删除，这是严重的 bug。有两种解决方法: **增量更新(Incremental Update)和
原始快照(Snapshot At The Beginning, SATB)**

**增量更新:**就是当黑色对象插入新的指向白色对象的引用关系时，就将这个新插入的引用记录下来，等并发扫描结束之后，再将这些记录过的引用关系中的黑色对象
为根，重新再扫描一次。简单理解是：**黑色对象一旦新插入了指向白色对象的引用之后，它就变回灰色对象，**

**原始快照:**就是当灰色对象删除指向白色对象的引用关系时，就将这个要删除的引用记录下来，在并发扫描结束之后，再将这些记录过的引用关系中的灰色对象为根，
重新扫描一次，这样就能扫描到白色对象，将白色对象标记为黑色(目的是为了让这种对象在本轮gc清理中活下来，待下一轮gc的时候重新扫描，这个对象也有可能是浮动垃圾)

无论是对引用关系的插入还是删除，虚拟机的记录操作都是通过**写屏障**实现的，


### 写屏障

给某个对象的成员变量赋值时，其底层代码大概长这样:

```
/**
 * @param field 某对象的成员变量 如 a.b.d
 * @param new_value 新值，如 null
 */
void oop_field_store(oop* field, oop new_value) {
    *field = new_value; // 赋值操作
}
```

写屏障就相当于在赋值操作前后添加处理

```
void oop_field_store(oop* field, oop new_value) {
    pre_write_barrier(field);   // 写屏障 - 写前操作
    *field = new_value;
    post_write_barrier(field, value); // 写屏障 - 写后操作 
}
```

* 写屏障实现 STAB

当对象 B 的成员变量的引用发生变化时，比如引用消失(a.b.d = null)，可以利用写屏障将 B 原来成员变量的引用对象 D 记录下来:

```
void pre_write_barrier(oop* field) {
    oop old_value = *field;    // 获取旧值
    remark_set.add(old_value); // 记录原来的引用对象
}
```

* 写屏障实现增量更新

当对象 A 的成员变量的引用发生变化时，比如新增引用(a.b = d)，可以利用写屏障将 A 新的成员变量引用记录下来:

```
void post_write_barrier(oop* field, oop new_value) {
    remark_set.add(new_value);  // 记录原来的引用对象
}
```

### 读屏障

```
oop oop_field_load(oop* field) {
    pre_load_barrier(field);  // 读屏障 - 读取前操作
}
```

读屏障是直接针对第一步: D d = a.b.d，当读取成员变量时，一律记录下来:

```
void pre_load_barrier(oop* field) {
    oop old_value = *field;
    remark_set.add(old_value); // 记录读取到的对象
}
```

现代追踪式(可达性分析)的垃圾回收器几乎都借鉴了三色标记的算法思想，尽管实现的方式不尽相同: 比如白色/黑色的集合一般都不会出现(但是有其他体现颜色的地方)、
灰色集合可以通过栈/队列/缓存日志等方式进行实现，遍历方式可以是广度/深度遍历等等。

* CMS: 写屏障 + 增量更新
* G1, Shenandoah: 写屏障 + STAB
* ZGC: 读屏障


### 记忆集和卡表

在新生代作 GCRoots 可达性扫描过程中可能会碰到跨代引用的对象，这种如果又去对老年代再次扫描效率太低了。

为此，在新生代可以引入记录集(Remember Set)的数据结构(记录从非收集区到收集区的指针集合)，避免把整个老年代加入 GCRoots 扫描范围。事实上并不只是
新生代、老年代之间才有跨代引用的问题，所有涉及部分区域收集(Partial GC)行为的垃圾收集器都存在这种问题。

垃圾收集场景中，收集器只需要通过记忆集判断出某一块非收集区域是否存在指向收集区域的指针即可，无需了解跨代引用指针的全部细节。hotspot 使用一种叫做"卡表"
(Cardtable)的方式实现记忆集，也是目前最常用的一种方式。关于卡表与记忆集的关系，可以类比为 Java 中 HashMap 和 Map 的关系。

卡表是使用一个字节数组实现的: CARD_TABLE[]，每个元素对应着其标识的内存区域一块特定大小的内存块，称为"卡页"。hotSpot 使用的卡页是 2 ^ 9 大小，即
512 字节。

![卡表 & 卡页](http://images.yuko.top/images/2022/03/09/ac2f4c8a417f.jpg)

一个卡页可包含多个对象，只要有一个对象的字段存在跨代指针，其对应卡表的元素标识就会变成 1，表示该元素变脏，否则为 0. GC 时，只要筛选本收集区的卡表中
变脏的元素加入 GCRoots 里。



