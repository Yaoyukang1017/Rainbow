JVM 对象创建与内存分配机制
===

## 对象的创建
对象创建的主要过程：

![对象的创建](http://yuko.top:9099/images/2022/03/03/_20220304093702.png)

### 1. 类加载检查

虚拟机遇到一条 new 指令时，首先将会去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和
初始化过。如果没有，那必须先执行相应的类加载过程。

new 指令对应到语言层面上来说：new 关键词、对象克隆、对象序列化等。

### 2. 分配内存

在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需内存大小的在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 java
堆中划分出来。

这个步骤可能会出现的问题：
1. 如何划分内存。
2. 在并发情况下，可能出现正在给对象 A 分配内存，指针还没来得及修改，对象 B 又同时使用了原来的指针来分配内存的情况。

**划分内存的方法：**
* 指针碰撞(Bump the Pointer) 默认使用指针碰撞
如果 Java 堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲
空间那边挪动一段与对象大小相等的距离。

* 空闲列表(Free List) 
如果 Java 堆中的内存并不是规整的，已使用的内存空间和空闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块
是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录。

**解决并发问题的方法：**

* CAS (compare and swap)
虚拟机采用**CAS配上失败重试**的方式保证更新操作的原子性来对分配内存空间的动作进行同步处理。

* 本地线程分配缓冲(Thread Local Allocation Buffer, TLAB)
把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在 Java 堆中预先分配一小块内存。通过 `-XX：+/-UseTLAB`参数来设定虚拟机是否使用 TLAB
  (JVM 会默认开启-XX:+UseTLAB)，-XX:TLABSize指定 TLAB 的大小。

### 3. 初始化零值

内存分配完成后，虚拟机需要将分配到的内存空间都初始化零值(不包括对象头)，如果使用 TLAB，这一工作过程也可以提前至 TLAB 分配时进行。这一步操作保证了
对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。

### 4. 设置对象头

初始化零值之后，虚拟机要对对象进行必要设置，例如这个对象是哪个类的实例，如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。这些信息
存放在对象的对象头之中。
在 HotSpot 虚拟机中，对象在内存中存储的布局可以分为 3 块区域：对象头(Header)、实例数据(Instance Data)和对齐填充(Padding)。HotSpot 虚拟机的对象头
包括两部分信息，第一部分是用于存储对象自身的运行时数据，如哈希码(HashCode)、GC分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等。对象头
的另外一部分就是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。

**32位对象头**

![32位对象头](http://yuko.top:9099/images/2022/03/04/clipboard-3.png)

**64位对象头**

![64位对象头](http://yuko.top:9099/images/2022/03/04/clipboard-4.png)

### 5. 执行 \<init\> 方法

执行 init 方法，即对象按照程序员的意愿进行初始化，对应到语言层面上讲，就是为属性赋值。(注意，这与上面的赋零值不同，这是由程序员赋的值)，和执行构造方法。


### 对象大小和指针压缩

什么是 java 对象的**指针压缩**？
1. jdk1.6 update14 开始，在 64 bit 操作系统中，JVM 支持指针压缩。
2. jvm 配置参数: UseCompressedOops, compressed--压缩、oop(ordinary object pointer)--对象指针
3. 启用指针压缩: -XX:+UseCompressedOops(默认开启)，禁止指针压缩: -XX:-UseCompressedOops

为什么要进行指针压缩？
1. 在 64 位平台的 HotSpot 中使用 32 位指针(实际存储用 64 位)，内存使用会多出 1.5 倍左右，使用较大指针在主内存和缓存之间移动数据，**占用较大
宽带，同时 GC 也会承受较大压力。**
2. 为了减少 64 位平台下内存的消耗，启用指针压缩功能。
3. 在 JVM 中，32 位地址最大支持 4G 内存(2 的 32 次方)，可以通过对对象指针的存入**堆内存**时压缩编码、取出到**cpu寄存器**后解码方式进行优化(
对象指针在堆中是 32 位，在寄存器中是 35 位，2 的 35 次方 = 32G), 使得 jvm 只用 32 位地址就可以支持更大的内存配置(小于等于 32G)。
4. 堆内存小于 4G 时，不需要启用指针压缩，jvm 会直接去除 32 位地址，即使用低虚拟空间。
5. 堆内存大于 32G 时，压缩指针会失效，会强制使用 64 位(即 8 字节)来对 java 对象寻址，所以会出现 1 的问题，所以堆内存不要大于 32G 为好。


